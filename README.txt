/*************************************************************
- C程序设计谭浩强版学习日志
- 作者：谢荣桢
- 版本：V1.0
*************************************************************/
-------------------------------------------------------------
2018/8/31（22:01）：
	第二章 算法--程序的灵魂
	2.2 算法举例实现
	问题：例2.4对分数多项式的求解中应使用float类型，包括函数返回值定义，
		同时运算中的常量必须是浮点数，否则会强制转换成整型，导致小数部
		分被抹去。
-------------------------------------------------------------
2018/9/1（7:49）：
	第二章 算法--程序的灵魂
	2.3 算法的特性
		有穷性
		确定性
		有零个或多个输入
		有一个或多个输出
		有效性

	2.4 怎样表示一个算法
		流程图（由菱形框和连接点组成）
	 	N-S流程图
		伪代码
		计算机语言

	2.5 结构化程序设计方法
		自顶向下
		逐步细化
		模块化设计
		结构化编程

	第三章 最简单的C程序设计――顺序程序设计
	3.1 顺序程序设计举例
	3.2 数据的表现形式及其运算
		常量：整型常量、实型常量、字符常量（普通字符，转义字符）、字符串常量、符号常量（#define，预编译后被置换，不分配存储单元）
		变量：先定义，后使用
		常变量（C99以后）：const前缀，有类型，占存储单元，但不允许改变其值。
		标识符：

		数据类型：
			整型
			浮点型
			枚举
			空类型（void）
			派生类型：
				指针
				数组
				结构体（struct）
				共用体（union）
				函数类型

		运算符和表达式
		注：(1)两个实数相除的结果是双精度实数，两个整数相除的结果为整数（舍去小数部分）
			若除数或被除数中有一个为负值，整数相除的舍入方向是不固定的。
			(2)i+++j 相当于 (i++)+j
			   i---j 相当于 (i--)-j
			(3)四则运算中有一个数为float或double,结果为double.
			   int和float运算，把两者转换为double,结果为double
			   char和int运算，如12+'A',等于12+65=77
			   char和实型数据运算，将ASCII代码转为double再运算。
----------------------------------------------------------------------
2018/9/1（17:49）：
	3.3 C语句
		控制语句
			if()...else...
			for()...
			while()...
			do...while()
			continue  --结束本次循环语句
			break     --中止执行switch或循环语句
			switch    --多分支选择语句
			return
			goto      --转向语句，在结构化程序中基本不用goto语句

		函数调用语句
		表达式语句
		空语句
		复合语句（{}内的语句和声明，又称语句块）

		注：当double数值赋给float变量时不能超出float变量的数值范围，否则会出错。
			占字节多的整型数据向占字节少的整型数据变量赋值，数组可能失真。
			只有静态存储变量和外部变量的初始化在编译阶段完成。

	3.4 数据的输入输出
		输入输出是以计算机主机为主题而言的。
		C语言本身不提供输入输出语句。
		float型数据只能保证6位有效数字。double型数据能保证15位有效数字。

		printf函数
		注：格式声明由 % 和 格式符 组成。将输出的数据转换为指定的格式然后输出。

		f格式符输出的数据向左对齐，用%-m.nf。
		e格式符以指数形式输出实数。
		o格式符以八进制整数形式输出。x格式符以十六进制数形式输出整数。
		u格式符输出无符号十进制整数。g格式符输出浮点数，不输出无意义的0。

		scanf函数（scanf(格式控制，地址表列)）
		scanf函数的地址表列是变量地址。

		注：执行getchar函数可以获得在屏幕上无法显示的字符，如控制字符。
-------------------------------------------------------------------------
2018/9/2（8:42）：
	第四章 选择结构程序设计
	4.1 选择结构和条件判断
		if语句：双分支选择
		switch语句：多分支选择

	4.2 用if语句实现选择结构
	4.3 关系运算符和关系表达式
		关系运算符优先次序
			(1)(<,<=,>,>=)优先级别相同，(==,!=)优先级别相同。前4种高于后2种。
			(2)关系运算符优先级低于算术运算符。
			(3)关系运算符优先级高于赋值运算符

	4.4 逻辑运算符和逻辑表达式
		逻辑运算符优先次序
			(1)!(非) > 算术运算符 > 关系运算符 > &&(与) > ||(或)。

		逻辑型变量（C99后新增)
			定义逻辑型变量用类型符_Bool
			包含头文件stdbool.h，可用bool代替_Bool
			注：逻辑型变量bool,true,false是C新标准，以增加程序可读性，有些老的C编译系统
				并未实现此功能，要注意。

	4.5 条件运算符和条件表达式
		条件表达式的一般形式：
			表达式1 ？ 表达式2 ：表达式3
		执行顺序：
			先求解表达式1，若真则求解表达式2，否则求解表达式3。

	4.6 选择结构的嵌套

	4.7 用switch语句实现多分支选择结构
		注意：switch后面的括号内的表达式值的类型应为整数类型。

	4.8 选择结构程序综合举例
		思考：例4.9程序是否可以简化，降低耦合，分解出一个或多个函数处理计算部分，剔除printf函数。
		  	  例4.10程序是否可以分解出单独的运费计算函数。
----------------------------------------------------------------------
2018/9/2（13:44）：
	完成第四章习题。
	习题11：a[i]>a[j] ? t=a[i],a[i]=a[j],a[j]=t : a[i]==a[i],a[j]==a[j];//第二个表达式不知为何不可赋值。
----------------------------------------------------------------------
2018/9/2（18:18）：
	第五章 循环结构程序设计
	5.1 为什么需要循环控制
	5.2 用while语句实现循环
		while语句：先判断条件表达式，为真，则执行循环体语句。

	5.3 用do……while语句实现循环
		do...while语句：先无条件地执行循环体，然后判断循环条件是否成立。
						do...while语句不管循环条件是否成立都至少执行一次循环体。

	5.4 用for语句实现循环
		for语句执行过程：(1)先求解表达式1.
						 (2)求解表达式2，若为真，则执行循环体语句，然后执行第(3)步。否则循环结束。
						 (3)求解表达式3。
						 (4)转回步骤(2).
		注：C99允许在for语句的表达式1中定义变量并赋初值。

	5.5 循环的嵌套
		3种循环可以互相嵌套。

	5.6 几种循环的比较
		3种循环都可用break语句跳出循环，用continue语句结束本次循环。

	5.7 改变循环执行的状态
		用break语句提前终止循环
		用continue语句提前结束本次循环
		由例5.5可知，continue语句只是结束本次循环，即本次不再执行循环体后续语句，然后开始新一轮的循环。
		注：continue语句只结束本次循环，而不是终止整个循环的执行。而break语句则是解释整个循环过程。

	5.8 循环程序举例

	完成到第五章习题8。
--------------------------------------------------------
2018/9/3（14:48）：
	完成第五章习题。
	注：习题9能否减少循环次数。
		习题12中的两种方法是等价的，但那种更合适
			(1)peachs = (peachs += 1)*2;
			(2)peachs += peachs;
			   peachs = peachs*2;
		习题13的关键while(fabs(x2-x1) >= 1e-5);
		习题14：牛顿迭代法不熟，对于函数间的数据传递掌握不足。
		习题15：我的算法似乎只考虑到区间内只有一个根的结果
		习题16：是否还有更简洁的方法？
		习题17：在最后一个if语句中加上可以显著减少多余的无谓的循环。但是否可以拆分如此之多的嵌套循环以减少语句运行。

		做题时的几个疑惑：
		1.如何在函数中返回多个值而不造成全局或整个当前文件的影响，函数内的变量的作用域只在函数内与调用函数内，
		  即返回的值只可被调用它的函数所使用而不能被其他函数通过赋值或指针的方式改变，也不会改变其他函数中的
		  同名变量或同名指针。同时函数如要调用其中的值无需用循环语句多次取单个值，而能用一条语句取出全部返回值。
--------------------------------------------------------
2018/9/4（18:37）：
	第六章 利用数组处理批量数据
	6.1 怎样定义和引用一堆数组
		1.定义一维数组的一般形式为：
			类型符 数组名[常量表达式];
		说明：
			(1)数组名的命名规则遵循标识符命名规则。
			(2)定义数组时，需要指定数组中元素的个数。
			(3)常量表达式中可以包括常量和符号常量。
		注：如果在被调用的函数(不包括主函数)中定义数组，其长度可以是变量或非常量表达式。
			如：
				void fnc(int n)
				{
					int a[2*n];
					...
				}

		2.引用一维数组元素
			数组名[下标]

		3.一维数组的初始化
			(1)在定义数组时对全部数组元素赋予初值。
			(2)可以只给数组中的一部分元素赋值
			(3)如果想使数组中全部元素为0，可写成：int a[10] = {0};
			(4)在对全部数组元素赋初值时，可以不指定数组长度：int a[] = {1,2,3}
			注：如果在定义数值型数组时，未指定初始化的元素，系统会自动把其初始化为0(字符型数组则初始化为'\0'，指针型数组初始化为NULL，即空指针。)

		4.一维数组程序举例
			例6.3 起泡法排序的基本思路：
				每次将相邻两个数比较，将小的调到前头。
				然后对余下的数按上面方法进行新一轮比较，直到没有未被排序的数。
				注：例6.3中的输入能否输入到第十个数就自动停止。

	6.2 怎样定义和引用二维数组
		1.二维数组定义的一般形式为：
			类型名 数组名[常量表达式][常量表达式]

			注：二维数组中元素排列的顺序是按行存放的，即对于a[2][3],先存放a[0][0]~a[0][2]再存放a[1][0]~a[1][2];
				在内存中，各元素是连续存放的，不是二维的，是线性的。

		2.引用二维数组的元素
			数组名[下标][下标]

			注：在引用数组元素时，下标值应在已定义的数组大小的范围内。

		3.二维数组的初始化
			(1)分行给二维数组赋初值。如：
				int a[2][4] = {{1,2,3},{4,5,6}};
			(2)将所有数据写在一个花括号内。
				int a[2][4] = {1,2,3,4,5,6};
			(3)可以对部分元素赋初值。

		4.二维数组程序举例
			例6.4 将语句 b[j][i] = a[i][j];放进循环表达式中是否更好。
				  例：for(j=0; j<=2; b[j][i] = a[i][j],printf("%5d",a[i][j++]))；

			例6.5 打擂台算法：
				先找一个人站在台上，第二个人上去与之比武，获胜者留在擂台上。
				再上去第三个人，与台上的人（即刚才的得胜者）比武，胜者留在台
				上，败者下台，直到所有的人都比试过后，最后留在擂台上的即是冠军。

				应用：求一组数据中的最大值或者最小值

	6.3 字符数组
		1.定义字符数组
			与定义数值型数组的方法类似。

		2.字符数组的初始化
		3.引用字符数组中的元素
		4.字符串和字符串结束标志
			C语言在输出字符数组中的字符串时，遇'\0'就停止输出；
			同时，在计算字符串的长度时要加上最后的结束标志'\0'.

		5.字符数组的输入输出
			(1)输出的字符不包括结束符'\0'。
			(2)用%s格式输出字符串时，printf函数中的输出项是字符数组名。
			(3)数组长度大于字符串的实际长度时，也只输出到遇'\0'结束。
			(4)一个字符数组包含一个以上'\0'，遇第一个'\0'时输出就结束。
			(5)可以用scanf函数输入一个字符串。
				注：scanf函数中的输入项不需再加&。

		6.使用字符串处理函数(包含头文件string.h)
			(1)puts函数--输出字符串的函数
				一般形式为：puts(字符数组)

			(2)gets函数--输入字符串的函数
				一般形式为：gets(字符数组)

			注：puts和gets函数只能输出或输入一个字符串。

			(3)strcat函数-- 字符串连接函数(strcat 是 string catenate（字符串连接）的缩写)
				一般形式为：strcat(字符数组1,字符数组2)
				说明：字符数组1必须足够容纳连接后的新字符串
					  连接后只在新串最后保留'\0'

			(4)strcpy和strncpy函数--字符串复制函数(strcpy 是 string copy的简写)
				一般形式为：strcpy(字符数组1,字符数组2)
							strncpy(字符数组1, 字符数组2,n) //n 为字符串2的前n个字符。
				说明：字符数组1的长度不小于字符串2
					  字符数组1必须写成数组名形式，字符数组2既可以是数组名也可是字符串常量
					  复制前字符数组1未初始化或赋值(其中的内容无法预知)，复制时将字符数组2中的字符串和'\0'复制到字符数组1，而数组1多余的字节的内容仍为其原有的数据(无法预知)
		 			  不能用赋值语句将一个字符串常量或字符数组直接给一个字符数组(赋值语句只能赋给一个字符变量或字符数组元素)。只能用strcpy函数。
					  可以用strncpy函数将字符数组2中的前n个字符复制到字符数组1以取代其原有的前n个字符。

			(5)strcmp函数--字符串比较函数(strcmp: string compare)
				一般形式为：strcmp(字符串1,字符串2)
				说明：字符串比较只能使用strcmp函数
					  比较自左至右比较ASCII码值，直到出现不同的字符或遇到'\0'。
					  相等时函数值为0；字符串1>字符串2，值为正整数；否则为负整数。

			(6)strlen函数--测字符串长度的函数(strlen: string length)
				一般形式为：strlen(字符数组)
				说明：函数的值为字符串的实际长度(不包括'\0')

			(7)strlwr函数--转换为小写的函数(strlwr: string lowercase(字符串小写))
				一般形式为：strlwr(字符串)
				说明：将字符串中的大写字母换成小写字母

			(8)strupr函数--转换为大写的函数(strupr: string uppercase(字符串大写))
				一般形式为：strupr(字符串)
				说明：将字符串中的小写字母换成大写字母

		7.字符数组应用举例
			例6.8 没有办法阻止误输入以及不合规格的输入只要有字母仍然会被当做字母进行计算。

	完成第六章习题
		注：例1：筛选法的步骤：
			<1> 先将1挖掉(因为1不是素数)。
			<2> 用2去除它后面的各个数，把能被2整除的数挖掉，即把2的倍数挖掉。
			<3> 用3去除它后面的各数，把3的倍数挖掉。
			<4> 分别用4,5…各数作为除数去除这些数以后的各数。
------------------------------------------------------------------
2018/9/15（23:15）：
	完成第六章习题
	习题6.4采用了最蠢的方法解决，程序健壮性，几乎不能处理其他情况，是投机取巧的解决。
	习题6.5使用了sizeof获取数组的位数，但是有一个问题没注意到:int类型在这台计算机中是占32位即4个字节，故需/4才能获得数组位数。

------------------------------------------------------------------
2018/9/24（13:24）：
	第七章 用函数实现模块化程序设计
	7.1 为什么要用函数
		函数就是功能。
		每一个函数用来实现一个特定的功能。
		函数的名字应反映其代表的功能。

	7.2 怎样定义函数
		(1).指定函数名
		(2).指定函数类型，即函数返回值的类型
		(3).指定函数参数的名字和类型。
		(4).指定函数的功能。

	7.3 调用函数
		1.函数调用语句
		2.函数表达式
		3.函数参数

		注：在定义函数中指定的形参，在未出现函数调用时，不占内存中的存储单元。
			调用结束时，形参单元被释放。

		7.3.4 函数的返回值
			(1).函数的返回值通过函数中的return语句获得。
			return语句只能返回一个确定值，但一个函数可以有一个以上的return语句，执行到哪个哪个就起作用。
			(2).函数值的类型
			在定义函数时指定函数值的类型
			(3).在定义函数时指定函数值的类型一般应该和return语句中的表达式类型一致。
			即函数类型决定返回值的类型。
			(4).对于不带返回值的函数，应当定义函数为“void类型”

	7.4 对被调用函数的声明和函数类型
		函数声明的一般形式：
			(1).函数类型 函数名(参数类型1 参数名1，参数类型2 参数名2，...，参数类型n 参数名n);
				void print(int num, char sex, float score);
			(2).函数类型 函数名(参数类型1，参数类型2，...，参数类型n)；
				void print(int, float, char);

	7.5 函数的嵌套调用
	7.6 函数的递归调用
		直接或间接地调用该函数本身，称为函数的递归调用。
		(1).如果在调用函数f的过程中，又要调用f函数，是直接调用本函数。
 		(2).如果在调用f1函数过程中调用f2函数，而在调用f2函数过程中又要调用f1函数，是间接调用本函数。


	7.7 数组作为函数参数
		1.数组元素可以用作函数实参，不能用作形参。
		2.用数组元素作实参时，向形参变量传递的是数组元素的值，而用数组名作函数实参时，向形参(数组名或指针变量)传递的是数组收元素的地址。
		3.多维数组名作为函数的实参和形参，在被调用函数中对形参数定义时可以指定每一维的大小，也可省略第一维的大小说明。

	7.8 局部变量和全局变量
		1.局部变量
			(1).在函数内部定义的变量只在本函数范围内有效。在复合语句内定义的变量只在本复合语句范围内有效。

		2.全局变量
			(1).在函数之外定义的变量称为外部变量，即全局变量。全局变量可以为本文件中其他函数所共用。
			(2).有效范围为从定义变量位置开始到本源文件结束。
			(3).不在必要时不要使用全局变量
				全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元。
				使函数的通用性降低
				全局变量使用过多，会降低程序的清晰性。

	7.9 变量的存储方式和生存期
		1.动态存储方式与静态存储方式
			内存中供用户使用的存储空间可分为3部分：
				(1).程序区
				(2).静态存储区
				(3).动态存储区

			全局变量全部存放在静态存储区，在程序开始执行时给全局变量分配存储区，程序执行完毕就释放。
			在动态存储区存放以下数据：
				(1).函数形式参数。在调用函数时给形参分配存储空间。
				(2).函数中定义的没有用关键字static声明的变量，即自动变量
				(3).函数调用时的现场保护和返回地址等。

			在C语言中，每一个变量和函数都有两个属性：数据类型和数据的存储类别。
				存储类别指的是数据在内存中存储的方式(如静态存储和动态存储)

		2.局部变量的存储类别
			(1)自动变量(auto变量)
				函数中的局部变量，如果不专门声明为static存储类别，都是动态地分配存储空间，数据存储在动态存储区中。
			(2)静态局部变量(static局部变量)
				静态局部变量属于静态存储类别，在静态存储区分配存储单元。在程序整个运行期间都不释放
				对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。每次调用函数时只是保留上次函数调用结束时的值。
				如果在定义局部变量时不服初值，对静态局部变量，编译时自动赋初值0或'\0'。对自动变量，值是一个不确定的值。
				静态局部变量在函数调用结束后仍存在，但其他函数不能引用它。
			(3).寄存器变量(register变量)
				注：如果有一些变量使用频繁，为提高执行效率，允许将局部变量的值放在CPU的寄存器中，称为寄存器变量。用关键字register作声明

		3.全局变量的存储类别
			(1).在一个文件内拓展外部变量的作用域
				如果外部变量作用域之外的函数需要引用该外部变量，在应该在引用之前使用关键字extern对该变量作"外部变量声明"。
				注：提倡将外部变量的定义放在引用它的所有函数之前，以避免在函数中多加extern声明
			(2).将外部变量的作用域拓展到其他文件
				注：用这样方法拓展全局变量的作用域应十分谨慎，因为执行一个文件中的操作可能会改变该全局变量的值，影响到另一文件中该变量的值，从而影响到执行结果。
			(3).将外部变量的作用域限制在本文件中
				加static声明，称为静态外部变量，只能用于本文件。

	7.10 关于变量的声明和定义
		建立存储空间的声明称定义
		不需要建立存储空间的声明称为声明

	7.11 内部函数和外部函数
		1.内部函数
			只能被本文件中其他函数所调用的函数称为内部函数，前面加static，又称静态函数
			通常把只能由本文件使用的函数和外部变量放在文件的开头，冠以static关键字使之局部化

		2.外部函数
			加关键字extern，是外部函数，可供其他文件调用，一般默认为外部函数。
------------------------------------------------------------------
2018/9/28（23:24）：
	第八章 善于利用指针
	8.1 指针是什么
		地址指向该变量单元：通过地址能找到所需的变量单元
		存储单元的地址 和 存储单元的内容
		直接访问方式：变量名访问
		简介访问方式：指针访问
		一个变量的地址称为该变量的“指针”，存储变量地址的变量称为“指针变量”
		指针变量的值是地址

	8.2 指针变量
		8.2.1 使用指针变量的例子
		8.2.2 怎样定义指针变量
			类型名 *指针变量名
			注：定义指针便令时必须指定基类型。
			一个变量的指针的含义包括两个方面：
				1.以存储单元编号表示的地址（如地址为0x2000的字节）
				2.它指向的存储单元的数据类型（如int，char，float等）
			指向整型数据的指针类型表示为“int *”。

		8.2.3 怎样引用指正变量
			1.给指针变量赋值：p=&a;
			2.引用指针变量指向的变量：*p=1;（若p=&a,则该语句相当于a=1）
			3.引用指针变量的值： printf("%o",p);（以八进制数形式输出a的地址）

		8.2.4 指针变量作为函数参数
			作用是将一个变量的地址传送到另一个函数中。
			如果想通过函数调用得到n个要改变的值：
				1.在主调函数中设n个变量，用n个指针指向它们。
				2.设计一个函数，有n个指针形参，在这个函数中改变这n个形参的值
				3.在主调函数中调用这个函数，在调用时将这n个指针变量作实参传给函数
				4.通过形参指针变量修改n个变量的值

	8.3 通过指针引用数组
		8.3.1 数组元素的指针
			数组元素的指针即数组元素的地址

		8.3.2 在引用数组元素时指针的运算
			指针指向数组时：
				1.加法
				2.减法
				3.自加
				4.自减
				5.指针相减

		8.3.3 通过指针引用数组元素
			1.下标法：a[i]
			2.指针法：*(a+i) 或 *(p+i)（其中p为指针变量，初值p=a）

		8.3.4 用数组名作函数参数
			实参类型：数组名
			形参类型：数组名或指针变量
			传递的信息：实参数组收元素地址
			能改变实参数组的值

------------------------------------------------------------------
2018/10/01（13:00）：
		8.3.5 通过指针引用多维数组
			1.多维数组元素的地址（以int类型的3行4列数组a[3][4]为例）
				a:二维数组名，指向一维数组a[0]，即0行首地址，例：（地址2000）
				a[0],*(a+0),*a:0行0列元素地址，例：（地址2000）
				a+1,&a[1]:1行首地址，例：（地址2016）
				a[1],*(a+1):1行0列元素a[1][0]的地址，例：（地址2016）
				a[1]+2,*(a+1)+2,&a[1][2]:1行2列元素a[1][2]的地址，例：（地址2024）
				*(a[1]+2),*(*(a+1)+2),a[1][2]:1行2列元素a[1][2]的值，例：（元素值为13）

			2.指向多维数组元素的指针变量
				(1).指向数组元素的指针变量
				(2).指向由m个元素组成的一维数组的指针变量
					从“int(*p)[4];”知p的类型为int(*)[4]型，p被定义为指向一维整型数组的指针变量，一维数组有4个元素，因此p的即类型是一维数组，其长度是16个字节。
				(3).用指向数组的指针作函数参数

	8.4 通过指针引用字符串
		8.4.1 字符串的引用方式
		8.4.2 字符指针作函数参数
			函数的形参和实参可以分别用字符数组名或字符指针变量。
			调用函数时实参与形参的对应关系
			实参				   	形参
			字符数组名             字符数组名
								  字符指针变量
			字符指针变量			 字符指针变量
								  字符数组名

		8.4.3 使用字符指针变量和字符数组的比较
			1.区别：
				(1).字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址。
				(2).可以对字符指针变量赋值，但不能对数组名赋值。
				(3).初始化的含义：数组可以在定义时对各元素赋初值，但不能用一条赋值语句对字符数组中的全部元素整体赋值，而字符指针则可以。用一条语句完成字符串的赋值
				(4).存储单元的区别：编译时为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元。
				(5).指针变量的值是可以改变的，而数组名代表一个固定的值(数组首元素的地址)，不能改变。

	8.5 指向函数的指针
		8.5.1 什么是函数指针
			定义的一个函数在编译时会分配一段存储空间用于存储函数代码，这段存储空间的起始地址(又称入口地址)称为这个函数的指针。

		8.5.2 用函数指针变量调用函数
			(1).通过函数名调用函数
			(2).通过指针变量访问它所指向的函数

		8.5.3 怎样定义和使用指向函数的指针变量
			类型名 (*指针变量名)(函数参数表列)

		8.5.4 用指向函数的指针作函数参数
			指向函数的指针变量的一个重要用途是把函数地址作为参数传递到其他函数。

	8.6 返回指针值的函数
		定义返回指针值的函数：类型名 *函数名(参数表列)

	8.7 指针数组和多重指针
		8.7.1 什么是指针数组
			一个数组的元素均为指针类型数据，称为指针数组
			定义一维指针数组：类型名 *数组名[数组长度];

		8.7.2 指向指针数据的指针
			指向指针数据的指针变量，称为指向指针的指针。

		8.7.3 指针数组作main函数的形参
			int main(int argc, char *argv[])(argc：argument chount,参数个数;argv：argument vector,参数向量)
			此时main函数是操作系统调用的，在操作命令状态下，实参是和执行文件的命令一起给出的。
			命令行的一般形式为：命令名 参数1 参数2 ......参数n

	8.8 动态内存分配与指向它的指针变量
		8.8.1 什么是内存的动态分配
			全局变量分配在内存中的静态存储区内，非静态的局部变量（包括形参）分配在内存中的动态存储区，这个存储区是一个栈(stack).
			内存动态分配区域，存放临时用的数据，这个自由存储区，称为堆(heap)区。

		8.8.2 怎样建立内存的动态分配
			1.使用malloc函数
				void *malloc(unsigned int size);
				作用：在内存的动态存储区中分配一个长度为size的连续空间。如果函数为成功执行(如内存空间不足)，返回空指针(NULL)

			2.使用calloc函数
				void *calloc(unsigned int n,unsigned int size);
				作用：在内存的动态存储区中分配n个长度为size的连续空间，这个空间一般比较大，足以保存一个数组。如果分配不成功，返回NULL。

			3.使用free函数
				void free(void *p);
				作用：释放指针变量p所指向的动态空间，使这部分空间能重新北其他变量使用。

			4.使用realloc函数
				void *realloc(void *p, unsigned int size);
				作用：已通过malloc函数或calloc函数获得了动态空间，可通过realloc函数重新分配。将p所指向的动态空间的大小改变为size。

		8.8.3 void指针类型
			指向空类型或不指向确定的类型

	8.9 有关指针的小结
		1.指针就是地址
			指针是地址本身，指针变量是用来存放地址的变量，即指针变量的值是一个地址。
		2.指向
			地址意味着指向，因为通过地址能找到具有该地址的对象。
		3.对数组的操作中使用指针，要清楚指针的指向。
		4.指针变量的归纳（《从程序设计》P289 表8.4）
		5.指针运算
			指针变量加减；指针变量赋值；指针变量相减；指针变量比较；
		6.指针变量可以有空值。例：p=NULL;

		使用指针的优点：
		1.提高程序效率
		2.在调用函数时当指针指向的变量值改变时，值也可被主调函数使用
		3.可以实现动态内存分配
------------------------------------------------------------------
2018/10/02（15:45）：
	第九章 用户自己建立数据类型
	9.1 定义和使用结构体变量
		9.1.1 自己建立结构体类型
			声明结构体类型：
			struct 结构体名
				{成员表列};
			成员表列中的成员的类型声明
			类型名 成员名;

		9.1.2 定义结构体类型变量
			1.先声明结构体类型，在定义该类型的变量
			2.在声明类型的同时定义变量
				strcut 结构体名
				{
					成员表列
				}变量名表列;
			3.不指定类型名而直接定义结构体类型变量
				struct
				{
					成员表列
				}变量名表列;
		9.1.3 结构体变量的初始化和引用
			1.定义结构体变量时可以对它的成员初始化。
			2.可以引用结构体变量中成员的值
				结构体变量名.成员名
			3.如果成员本身又属于一个结构体类型，则要使用若干个成员运算符，一级一级地找到最低的一级的成员。
			4.对结构体变量的成员可以像普通变量一样进行各种运算。
			5.同类的结构体变量可以互相赋值
			6.可以引用结构体变量成员的地址，亦可以引用结构体变量的地址。

	9.2 使用结构体数组
		9.2.1 定义结构体数组
			1.定义结构体数组
				(1).struct 结构体名
				{成员表列}数组名[数组长度];
				(2).先声明一个结构体类型，再定义
				结构体类型 数组名[数组长度];
			2.对结构体数组初始化的形式是在定义数组后加上
			= {初值表列}：
		9.2.2 结构体数组的应用举例

	9.3 结构体指针
		9.3.1 指向结构体变量的指针
			指针变量的基类型必须与结构体变量的类型相同
			stuct Student *pt; //pt可以指向struct Student类型的变量或数组元素
			如果pt指向一个结构体变量(Student stu)，以下3种用法等价：
			1.stu.成员名;
			2.(*pt).成员名;
			3.p->成员名;

		9.3.2 指向结构体数组的指针
			可以用指针变量指向结构体数组的元素。
			stuct Student stu[3];
			stuct Student *p;p = stu[1];
			如果要将结构体数组的stu[1]的成员付给p,可以用强制类型转换，将成员的地址转换成P的类型
			p = (stuct Student *)stu[1].name;

		9.3.3 用结构体变量和结构体变量的指针作函数参数
			将结构体变量的值传递给另一个函数
				1.用结构体变量的成员作参数。
				2.用结构体变量作实参。
				3.用指向结构体变量(或数组元素)的指针作实参，将结构体变量(或数组元素)的地址传给形参。

	9.4 用指针处理链表
		9.4.1 什么是链表
			1.链表有一个“头指针”变量，存放一个地址，改地址指向一个元素
			2.链表中每一个元素称为“结点”，每个结点包括两个部分
				(1).用户数据
				(2).下一个结点的地址
			3.链表中各元素在内存中的地址可以是不连续的。
			4.链表必须利用指针变量才能实现，即一个结点中应包含一个指针变量用于存放下一结点的地址。

		9.4.2 建立简单的静态链表
		9.4.3 建立动态链表
			指在程序执行过程中从无到有地建立起一个链表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。
		9.4.4 输出链表
			将链表中各结点的数据依次输出。

	9.5 共用体类型
		9.5.1 什么是共用体类型
			定义共用体类型变量(也称为“联合”)
				union 共用体名
				{
					成员表列
				}变量表列;
			共用体变量所占的内存长度等于最长的成员的长度，所有的成员共用一段内存，数据会互相覆盖。

		9.5.2 引用共用体变量的方式
		 	不能引用共用体变量，只能引用共用体变量中的成员。
			例：union
				{
					int i;
					char ch;
					float f;
				} a,b,c;
				printf("%d",a.i);

		9.5.3 共用体类型数据的特点
			1.同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员
			2.可以对共用体变量初始化，但初始化表中只能有一个常量。
			3.共用体变量中起作用的成员是最后一次被赋值的成员。
			4.共用体变量的地址和它的各成员的地址都是同一地址
			5.不能对共用体变量名赋值，也不能引用变量名来得到一个值
			6.C99之后允许共用体变量作为函数参数
			7.共用体类型可以在结构体类型定义中，也可以定义共用体数组。反之亦可。

	9.6 使用枚举类型
		声明枚举类型
			enum Weekday{sun,mon,tue,wed,thu,fri,sat};
		定义变量
			enum Weekday workday,weekend;
		workday和weekend被定义为枚举变量，sun,mon,...,sat称为枚举元素或枚举常量。
		枚举常量代表一个整数，默认顺序从0依次递增。
		也可人为指定枚举常量的数值，在定义时指定。
		enum Weekday{sun=7,mon=1,tue,wed,thu,fri,sat}workday,weekend;
		此时sun=7，mon~sat依次为1,2,3,4,5,6.

	9.7 用typedef声明新类型名
		1.简单地用一个新的类型名代替原有的类型名
		2.命名一个简单的类型名代替复杂的类型表示方法
			(1)命名一个新的类型名代表结构体类型
				typedef struct
				{
					int month;
					int day;
					int year;
				}Date;
				Date birthday;		//定义结构体变量birthday;
			(2).命名一个新的类型名代表数组类型
				typedef int Num[100]; //声明Num为整型数组类型名
			(3).命名一个新的类型名代表指针类型
				typedef char* String; //声明String为字符指针类型
			(4).命名一个新的类型名代表指向函数的指针类型
				typedef int (*Pointer)(); //声明Pointer为指向函数的指针类型，该函数返回整型值。
		注：typedef与#define不同
			#define在预编译时处理，作简单的字符串替换
			typedef在编译阶段处理，生成类型名，然后去定义变量。
------------------------------------------------------------------
2018/10/03（11:14）：
	第十章 对文件的输入输出
	10.1 C文件的有关基本知识
		10.1.1 什么是文件
			1.程序文件
				包括源程序文件(.c)、目标文件(.obj)、可执行文件(.exe)等
			2.数据文件
				操作系统把各种设备都统一作为文件来处理
				文件：一般指存储在外部截止上数据的集合
				输入输出是数据传送的过程，形象地称为流(stream)，即数据流;流表示了信息从源到目的端的流动

		10.1.2 文件名
			文件标识(也即文件名)包括：
				1.文件路径
				2.文件名主干
				3.文件后缀

		10.1.3 文件的分类
			根据数据的组织形式，可分为
				1.ASCII文件(也称为文本文件(text file))
				2.二进制文件(不加转换地输出到外存，可认为是存储在内存的数据的映像，故也称为映像文件(image file))

		10.1.4 文件缓冲区
			ANSI C标准采用“缓冲文件系统”处理数据文件，即系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区。

		10.1.5 文件类型指针
			文件类型指针，简称文件指针。
			每个被使用的文件都在内存中开辟一个相应的文件信息区，存放文件的有关信息(如文件名、文件状态及文件当前位置等)，这些信息放在一个结构体变量中。
			通过文件指针指向该结构体变量，可以通过文件指针变量找到与该结构体变量关联的文件。

	10.2 打开与关闭文件
		10.2.1 用fopen函数打开数据文件
			调用方式：
				fopen(文件名，使用文件方式);
			使用文件方式包括：
				1."r"(只读)：打开一个已存在的文本文件读取内容，若果文件不存在则出错
				2."w"(只写)：打开一个文本文件写数据，若果文件不存在则建立该文件
				3."a"(追加)：向文本文件尾添加数据，若果文件不存在则出错
				4."rb"(只读)：打开一个二进制文件读取内容，若果文件不存在则出错
				5."wb"(只写)：打开一个二进制文件写数据，若果文件不存在则建立该文件
				6."ab"(追加)：向二进制文件尾添加数据，若果文件不存在则出错
				7."r+"(读写)：打开一个文本文件读写数据，若果文件不存在则出错
				8."w+"(读写)：建立一个新的文本文件读写数据，若果文件不存在则建立该文件
				9."a+"(读写)：打开一个文本文件，文件读写位置标记移到文件尾读写数据，若果文件不存在则出错
				10."rb+"(读写)：打开一个二进制文件读写数据，若果文件不存在则出错
				11."wb+"(读写)：建立一个新的二进制文件读写数据，若果文件不存在则建立该文件
				12."ab+"(读写)：打开一个二进制文件，文件读写位置标记移到文件尾读写数据，若果文件不存在则出错

			程序中可以使用3个标准的流文件
				1.标准输入流：从终端输入
				2.标准输出流：向终端输出
				3.标准出错输出流：当程序出错时将出错信息发送到终端

		10.2.2 用fclose函数关闭数据文件
			调用方式：
				fclose(文件指针);

	10.3 顺序读写数据文件
		10.3.1 怎样向文件读写字符
			1.fgetc(fp):从fp指向的文件读入一个字符；读成功，返回所读的字符，失败返回文件结束标志EOF(即-1)
			2.fputc(ch,fp):把字符ch写到文件指针变量fp所指向的文件中；输出成功，返回所输出的字符，失败返回EOF(即-1)

		10.3.2 怎样向文件读写一个字符串
			1.fgets(str,n,fp):从fp指向的文件读入一个长度为(n-1)的字符串，存放到字符数组str；读成功，返回地址str，失败返回NULL
			2.fputs(str,fp):把str所指向的字符串写到fp所指向的文件中；输出成功，返回0；否则返回非0值

		10.3.3 用格式化的方式读写文件
			格式化输入输出
				fprintf(文件指针，格式字符串，输出表列);
				fscanf(文件指针，格式字符串，输入表列);

		10.3.4 用二进制方式向文件读写一组数据
			fread(buffer,size,count,fp);
			fwrite(buffer,size,count,fp);
				buffer：一个地址。用来存放从文件读入的数据的存储区的地址。
				size：要读写的字节数
				count：要读写多少个数据项(每个数据项长度为size)
				fp：FILE类型指针。

	10.4 随机读写数据文件
		10.4.1 文件位置标记及其定位
			1.文件位置标记(即文件位置指针)
				用来指示接下来要读写的下一个字符的位置
			2.文件位置标记的定位
				可以强制使文件位置标记指向人们指定的位置。
				(1).rewind函数使其指向文件开头
					rewind(文件类型指针)
				(2).用fseek函数该表文件位置标记
					fseek(文件类型指针,位移量,起始点)
					起始点用0、1、2代替，0表示文件开始位置，1表示当前位置，2为文件末尾位置
					位移量指以起始点为起点，向前移动的字节数。为long型数据(例：100L)，可以是负值(即向后位移)

		10.4.2 随机读写
			使用rewind和fseek函数实现任意位置数据读写

	10.5 文件读写的出错检测
		1.ferror函数
			ferror(fp);
			如果返回0，指为出错；返回非0值，表示出错
			注：每一次调用输入输出函数，都会产生一个新的ferror函数值。故每次调用输入输出函数应立即检查ferror函数值
				在执行fopen函数时，ferror函数初始值自动置0

		2.clearerr函数
			clearerr(fp);
			作用：使文件错误标志和文件结束标志置为0.
				如果输入输出函数出现错误后，应在下一次检测之前调用ferror函数前使用clearerr函数将ferror函数值置0。
